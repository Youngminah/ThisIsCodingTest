## 05. DFS/BFS

</br>

</br>

- 💡 **탐색과 자료구조**

>  탐색이란, 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
>
>  자료구조란, 데이터를 표현하고 관리하고 처리하기 위한 구조

 대표적인 탐색 알고리즘으로 DFS, BFS를 꼽을 수 있다. 이 두 알고리즘의 원리를 제대로 이해해야 코딩 테스트의 탐색 문제 유형을 풀 수 있다.

</br>

</br>


- 💡 **그래프 표현 방식**

**인접 행렬** : 2차원 배열로 그래프의 연결 방관계를 표현하는 방식

```python
INF = 999999999

graph = [
    [0, 7, 5],
    [9, 0, INF],
    [5, INF, 0]
]

print(graph) // [[0,7,5], [7,0,99999999], [5, 99999999, 0]] 출력
```

**인접 리스트** : 리스트로 그래프의 연결 관계를 표현하는 방식.

```python
graph = [[] for _ in range(3)]

//0번 노드랑 연결된 노드는 1번,2번이며 각각의 비용은 7,5이다.
graph[0].append((1,7))
graph[0].append((2,5))
//1번 노드랑 연결된 노드는 0번이며, 비용은 7이다. 
graph[1].append((0,7))
//2번 노드랑 연결된 노드는 0번이며, 비용은 5이다.
graph[2].append((0,5))

print(graph) //[[(1,7), (2,5)], [(0,7)], [(0,5)]] 출력
```

**차이점** : 인접 행렬 방식은 모든 관계를 저장하므로 메모리가 불필요하게 낭비되는 반면, 인접 리스트 방식은 연결된 정보만을 저장하기 때문에 메모리를 효율적으로 사용한다.

하지만, 이와 같은 속성 때문에 인접 리스트 방식은 인접 행렬 방식에 비해 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻는 속도가 느리다. (하나하나 확인해야하기 때문이다.)

</br>

</br>


- 💡 **DFS**

깊이 우선 탐색이라고도 부르며, 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘이다. DFS는 **스택 자료구조**에 기초하여 구현하면 간단하다. 데이터의 개수가 N개인 경우 O(N)의 시간이 소요된다는 특징이 있다.  

</br>

> DFS는 스택을 이용하는 알고리즘이기 때문에 , 재귀 함수를 이용했을 때 매우 간결하게 구현할 수 있다.

</br>

</br>

- 💡 **BFS**

너비 우선 탐색이라고도 부르며, 그래프에서 가까운 부분부터 알고리즘이다. BFS는 **큐 자료구조**에 기초하여 구현하면 간단하다.  파이썬의 deque 라이브러리를 이용하는 것이 좋으며, 데이터의 개수가 N개인 경우 O(N)의 시간이 소요된다는 특징이 있다. 일반 적인 경우 실제 수행 시간은 DFS보다 좋은 편이다. 

</br>

파이썬을 이용할 때에는 deque를 사용하여 구하는 것이 좋다. 리스트랑 차이가 없어 보이지만, **파이썬에서 deque가 리스트보다 시간 면에서 빠르기 때문**이다.

</br>

</br>

- 💡 **DFS , BFS 비교**

|           | DFS            | BFS              |
| --------- | -------------- | ---------------- |
| 동작 원리 | 스택           | 큐               |
| 구현 방법 | 재귀 함수 이용 | 큐 자료구조 이용 |

</br>

완전탐색이라면 BFS, DFS에서 사실상 시간은 비슷하지만 일반적으로는 BFS가 더 성능이 좋고 보면된다.

왜냐하면 **DFS는 재귀함수를 이용하며 BFS는 반복문을 기반으로 하기 때문**

 </br>

재귀와 반복의 시간차이는 피보나치 수열로 확인해보면 알 수 있다.

</br>

**하지만, 완전 탐색이 아니라면**

Backtracking같은 곳에서는 이야기가 다르다.

백트래킹에서는 DFS가 더 성능이 좋은경우가 많다. (예를들어 branch and bound)

**Best first search (우선순위 큐 이용) > Depth first search (스택 이용) > Breath first search (큐 이용) 순**이다.

이 밖에 더 좋은 알고리즘이 있을 수 있다.

 </br>

어찌됐든 완전탐색을 해야하는 경우라면 BFS를 선호하는 것이 좋다.

 </br>

**인접행렬을 기반**으로 BFS와 DFS를 구하여려면 두가지 모두 기본적으로는 visited (방문에 관한 내용을 담을 리스트)가 필요하다.

하지만 인접 행렬이 아니라면 이것 또한 유동적으로 방문 리스트는 없이 구현할 수도 있다.

</br>

</br>



💡 **결론**


> 각 간선들간의 가중치가 없는데 최단거리를 구하라하면 BFS, 간선들간의 가중치까지 있다면 그때는 다익스트라, 프림, 크루스칼 등을 이용하면 된다 

</br>

</br>

