## 06. 정렬

</br>

💡 **정렬이란**

>  데이터를 특정한 기준에 따라서 순서대로 나열하는 것

 정렬 알고리즘으로 데이터를 정렬하면,이진 탐색이 가능해진다. 

</br>

</br>


💡 **정렬 시간복잡도 비교**

|                | 선택   | 삽입   | 퀵       | 계수   | 합병     | 버블   |
| -------------- | ------ | ------ | -------- | ------ | -------- | ------ |
| 평균시간복잡도 | O(n^2) | O(n^2) | O(nlogn) | O(N+K) | O(nlogn) | O(n^2) |

</br>

</br>

💡 **선택정렬**

가장 작은 데이터 ( 또는 가장 큰 데이터 )를 선택하여 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째와 바꾸는 과정을 반복.

 선택 정렬은 코드로 구현하기 쉬우나, 데이터의 갯수가 늘어나면 늘어날수록, 현저히 느리게 작동하는 것을 확인 할 수 있다. **데이터가 많아지면 비효율적**이다.



</br>

</br>

💡 **퀵정렬**

피벗을 사용하여 기준을 정한뒤 작은 수 를 교환하고, 리스트를 반으로 나누는 방식으로 동작한다. 구현하는 데는 까다롭지만 대부분의 정렬 라이브러리의 근간이 되는 알고리즘이다. 

 분할을 사용하기 때문에 기하급수적으로 줄어들어 O(nlogn)과 같은 성능을 가질 수 있음.



하지만, **최악의 경우 O(n^2)의 성능 나올수도 있다는 것이 단점!**

우리가 쓰는 라이브러리에 구현된 퀵정렬은 최악의 상황에서도 O(nlogn)을 보장할 수 있도록 약간의 로직 처리가 되어있다.

</br>

</br>

💡 **계수정렬**

시간복잡도로만 보면 기수정렬과 더불어 **가장 빠른 정렬법**. 단점은 메모리가 사용이 많이된다

공간복잡도의 한계가 있기때문에 일반적으로 가장 큰 데이터와 가장 같은 데이터의 차이가 1000000을 넘지 않을때 효과적.

</br>

예를들어, 0이상 100이하인 성적 데이터를 정렬할 때 계수 정렬이 효과적이다. 

다만, 가장 작은 데이터와 가장 큰 데이터의 차이가 너무 크다면 계수 정렬은 사용하는 것은 비효율 적이다. 이러한 이유는 계수정렬은

> 모든 범위를 담을 수 있는 크기의 리스트를 선언

해야하기 때문이다.

</br>

**동일한 값을 가지는 데이터가 많을 경우 유리하고 데이터 크기에 한정적이기 때문에 한정적으로 사용**되어야 한다 

따라서 조건을 보고 유동적으로 사용. 데이터의 크기가 한정되어 있고, 데이터의 크기가 많이 중복되어 있을 수록 유리하다.



</br>

</br>

💡 **합병정렬**

분할 정복에 대표적인 정렬 방법

데이터 분포에 상관없이 안정적인 O(nlog)의 성능을 보여주지만 **추가적인 리스트를 사용해야함**.

</br>

</br>

💡 **버블정렬**

기초중에 기초 정렬 

앞뒤를 바꾸는 아이디어가 꼭 필요할 때가 있으므로 알아두는 것이 좋다

</br>

</br>

💡 **결론**

- **정렬 라이브러리로 풀 수 있는 문제** : 단순히 정렬 기법을 알고 있는지 물어보는 문제로 라이브러리 그냥 이용하면 됨
- **정렬 알고리즘의 원리에 대해서 물어보는 문제** : 선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 문제를 풀 수 있다.
- **더 빠른 정렬이 필요한 문제** : 퀵 정렬 기반의 정렬 기법으로는 풀 수 없으며 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 구조적 개선을 해야함.

</br>

</br>



