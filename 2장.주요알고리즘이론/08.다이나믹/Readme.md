## 08. 다이나믹 프로그래밍

</br>

- 💡 **다이나믹 프로그래밍의 핵심**

>  수열의 점화식을 구하자!

중복되는 연살을 줄이자. 연산 속도와 메모리 공간을 최대한으로 활용할 수 있는 효율적인 알고리즘을 작성

현재의 항들로 다음 항을 구할수 있는 경우 다이나믹 프로그래밍을 쓴다.



**대표적 예시 >> 피보나치 수열**



</br>

- 💡 **피보나치 재귀 함수**

>  반으로 쪼개면서 중간점을 기준으로 탐색 O(logn)

구현하긴 간편하지만 숫자가 커지면 기하급수적으로 연산횟수가 늘어난다.

f(100)을 구하기 위해서는 약 1,000,000,000,000,000,000,000,000,000,000 번 연산을 해야한다. 수백억년이 넘어가는 시간이 걸림.

</br>

</br>


- 💡 **피보나치 다이나믹 프로그래밍(탑다운 방식)**

 하지만 피보나치를 다이나믹으로 풀 경우, 같은 문제라면 한번 씩만 풀어 저장해 놓기 때문에 **(메모이제이션 또는 캐싱)** 효율적으로 해결하게 된다. O(N)의 성질을 보임.

**다이나믹 프로그래밍을 이용하여 피보나치 수열 문제를 풀었던 방법을 잘 알아두면 다른 다이나믹 프로그래밍 접근 하는 방법 또한 떠올릴 수 있다**

수열을 배열이나 리스트, 딕셔너리로 표현하여 이용할 수 있다.

단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 **보텀업 방식**이라고 한다.

</br>

</br>

💡 **다이나믹 프로그래밍 코딩테스트**

그렇다면 무엇을 사용하여야 할까?

특정한 문제를 완전 탐색을 적용 하였을 때, 시간이 매우 오래걸린다면, 다이나믹 프로그래밍이 적용 가능한지 알아보기 위하여 , **해당 문제의 부분문제가 중복**이 되는지 확인해본다.

가능하면, 재귀를 이용한 탑다운 방식보다는 보텀업 방식으로 구현하는 것을 권장한다!!

시스템상 재귀함수의 스택 크기가 한정되어 있을 수 있기 때문이다. 실제로 탑다운방식으로 피보나치를 구하면, 오천 번째 이상의 큰 피보나치 수에서 오류가 발생 할 수 있다.

</br>

</br>
