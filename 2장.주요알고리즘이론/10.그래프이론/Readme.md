## 10. 그래프 이론

</br>

💡 **그래프의 구현 방법**

- 인접 행렬 :  2차원 배열을 사용하는 방식.

  인접 행렬의 경우 O(v^2)만큼의 메모리 공간 필요 (메모리 측면)

  인접 행렬의 경우는 특정 노드의 간선의 비용을 알기 위해선 O(1)의 비용이 듦 (속도 측면)



- 인접 리스트 : 리스트를 사용하는 방식.

  인접 리스트의 경우 O(E) 만큼의 메모리 공간 필요 (메모리 측면)

  인접리스트의 경우는 특정 노드의 간선의 비용을 알기 위해선 O(V) 만큼의 시간이 든다. (속도 측면)

</br>

</br>

💡 **서로소 집합** : 공통 원소가 없는 두 집합

>  **핵심 : Parent 배열을 생성하여 재귀 함수로 부모노드를 찾는다.**

만약 부모노드가 같으면 서로소가 아니라 같은 집합에 있는 노드.



서로소 집합 자료구조는 union,find 이 2개의 연산으로 조작할 수 있다.

union_parent, find_parent 함수 구현하면 반은 완성

대략 **O(nlogn)**



**사이클 판별**: union 실행하기 전에 이미 루트 노드가 같다면 사이클 발생.

</br>

</br>

💡 **크루스칼 알고리즘**

최소비용 신장트리 만드는 알고리즘 O(eloge)

원리: 사이클이 발생하지 않는 한, 간선의 최소부터 집합에 포함한다. 따라서, 간선은 정렬해 놓기.



</br>

</br>

💡 **위상 정렬**

> 방향 그래프의 모든 노드를 '방향성에 거스르지 않도록 순서대로 나열하는 것'이다.

큐와 리스트를 이용하여, 노드를 정렬하는 방식 ( 답은 한가지가 아니라 여러가지가 될 수 있음 )

BFS를 이용한다고 봐도 무방할 정도로 매우 비슷함 **O(v+e)**

</br>

</br>
